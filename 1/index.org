基本概念

* 前文
- 関数プログラミング
  - 定義を構築し、式を評価する
- プログラマの役割
  - 問題を解くための関数を構成
  - + DSLの作成とも言えそう
- 計算機は電卓とも言える
  - 関数型の電卓の計算能力はプログラマの腕しだい
- 定義した関数
  - 印字可能な形式への変換規則
* 1.1 セッションとスクリプト
- セッション
  - 式を入力すると評価結果が変える
  - このような流れの利用者と計算機の対話をセッション
- スクリプト
  - 定義を並べたもの
  - 定義を構築することが知的作業
- 型シグネチャ
  - 定義の一部
  - 関数についてる情報
- 定義の目的
  - 束縛
    - 与えられた式に名前をつける
  - 環境 文脈
    - 束縛の集り
  - 式は ある文脈によって評価される
  - + 式の中で使える名前は 文脈によって決定する
- プログラマが文脈を与えなくても評価できる式がある
  - プレリュード
    - 特別扱いのスクリプトでよく使う演算を定義済み
    - セッション開始時によみこまれる
** 練習問題
- [[file:1.1.hs]]
** 個人的まとめ
[[http://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-1/][blog記事]]
* 1.2 評価
- 評価
  - 式をもっとも単純で等価な形式に簡約
  - 結果を求める
  - 評価、簡約、単純化は区別なく使用する
- 標準形, 正規形
  - これ以上簡約できない
- 簡約系列
  - ? 簡約の手順書
  - 複数存在する
  - 関数プログラミングではどの手順でも最終結果が一致する
  - ただし、停止する場合に限る
  - 手順によっては停止する場合としない場合がある
  - 遅延評価という簡約戦略を使用する -> 7章
** 練習問題
- [[file:1.2.md]]
** 個人的まとめ
[[http://blog.eiel.info/blog/2013/01/13/intro-functional-1-dot-2/][blog記事]]
* 1.3 値
- 式を用いて表現する
  - 式もそのためだけに使用する
- 数値、論理値、文字、タプル、関数、リスト がある
- 新しい値も導入できる
- 式の最も単純な形式は 値 ではない。
  - 値を表現するものの ひとつにすぎない
  - 評価機は値を表示する際 標準表現 を用いる
    - 標準表現が存在しない値もある
      - 例 関数
    - 有限な表現がない場合がある
      - 例 円周率
- 簡約が停止しない式は 値とは言えない
  - 例 1/0
  - このような場合には bottom という未定義値を導入するとよい
  - 1/0 = bottom
  - 評価機が bottom を評価した場合は評価機依存
- 正格関数
  - f bottom = bottom となる関数
  - bottom が評価されるので エラーになったり無限に簡約されたり
- 非正格関数
  - f bottom /= bottom となる関数
  - bottom が評価されないのでエラーになったりしない
  - 例 three x = 3
  - 遅延評価でなければ定義できない
** 練習問題
- [[file:1.3.md]]
** 個人的まとめ
- [[http://blog.eiel.info/blog/2013/01/15/intro-functional-1-dot-3/][blog記事]]
* 1.4 関数
- 関数は値
- 関数プログラミングで最も重要な値
- 値の表示はできない
- 引数を適用した結果は表示できる
  - もちろん、表示できる場合
- 関数はある 型A のひとつひとつの要素を 型X の値のひとつに対応つける
  - 型A のことを 始域
  - 型B のことを 終域
  - f :: A -> B とかく
    - 型A の引数をとり 型B の結果を返す
  - f の型を示す
  - A と B が 型なら A -> B も型
  - x が Aの要素のとき
    - 関数 f に x に適用した結果を f x, f (x) とかく
      - この値は B の要素
      - f の対応規則によって x と関連づけられている
      - 括弧は 複雑な式の場合必要
  - 関数 と 関数に適用したもの を混同しないように
  - 関数は他の値と同等に値
** 外延性
- ふたつの関数が等しいとは？
  - 同じ引数に対し同じ結果を返す
  - 任意のx について f x = g x のとき f = g
    - この証明方法を
      - 適用的証明
      - ポイントワイズスタイル
  - 外延性の原理
- 定義が違って 対応をとる手続きが違う場合でも一致することがある
  - ただし、効率は違う
    - 効率は内包的性質
  - 定義によって f = g を示すことを
    - ポイントフリースタイル
** カリー化
- 単一の引数を複数の引数に分解すると便利なことがある
  - カリー化
  - (Int, Int) -> Int を Int -> (Int -> Int) に
    - ! -> は右結合なので Int -> Int -> Int でも等価
  - 本質的にはそのまま
  - smaller
    - smaller (x,y) = if x < y then x else y
    - smaller x y = if x < y then x else y
  - Haskell B. Curry にちなんで カリー化
- 関数は左結合
  - smaller 3 4 とかいたとき  (smaller 3) 4 と等価
- カリー化の利点
  - 書くべき括弧が減る。
  - カリー化した関数に引数をひとつだけ与えて便利な関数がつくれる
- カリー化されてない関数をカリー化する curry 関数がある
  - ! 引数がちょっと読みづらい。慣れの問題だろうか
  - 逆にカリー化されてない関数にする uncurry がある
    - ! 組を生成してそのまま渡せて便利な場合がある Arrowとか
** 演算子
- ふたつの引数の間におくもの
  - ! 演算子に渡すのも引数
- 曖昧さをなくすために特別な記号が演算子にできる
- バッククオートを使うと関数も演算子になる
  - mod 10 3 -> 10 `mod` 3
- 括弧を使うと演算子も通常の関数のように使える
  - (+) 10 3 -> 10 + 3
** セクション
- 括弧で演算子を使うのは拡張できる
  - (1+) 2 -> 1 + 2
  - (+2) 1 -> 1 + 2
** 優先順位
- 式の中で演算子が登場すると曖昧さが発生する
- 演算子には優先順位が存在する
- 括弧を省略するためにある
- 関数適用が最優先
  - ! 演算子がない部分から考えて、優先順位がつよい演算子から処理する
  - ! hoge 1 + mogu 2 + 3 * 4 -> (hoge 1) + (mogu 2) + (3 * 4)
** 結合順序
- 括弧を減らすもうひとつの仕組み
- 左結合か右結合にできる
- 左結合
  - 1 +++ 2 +++ 3 -> ((1 +++ 2) +++ 3)
- 右結合
  - (1 +++ ( 2 +++ 3))
- 結合性 どちらから結合しても意味が変わらない
** 関数合成
- 関数合成は結合性である
- f . g とかく
- (b -> c) -> (a -> b) -> (a -> c)
  - (f . g) a  は f (g x) と等価
  - 先に g (aがbになる) に適用され fが適用され (bがcになる)
  - 結果 a -> c の関数ができる
** 練習問題
[[file:1.4.md]]
** 個人的まとめ
[[http://blog.eiel.info/blog/2013/01/22/intro-functional-1-dot-4/][blog記事]]
* 1.5 定義
- 関数ばかり定義したけど他の値も 定義可能
- ガード付等式
  - ブール値になる式を利用すると ガード付等式 を使った定義ができる
  - 3つ以上のガードがあるならおすすめ
  - ふたつの場合は if を使おう
  - 3つの場合は if ではわかりにくい
** 再帰定義
- 定義は再帰的に使える
  - 定義中に自分自身を使える
- 停止しなくなるよりは停止してエラーを出力するほうがよい
** 局所定義
- where を使用する
- その関数の定義中が有効範囲
- ! let は出てこない？
- ! ガードの場合は両方で使えるけどパターンマッチを使った定義だと片方だけ
** 練習問題
[[file:1.5.hs]]
* 1.6 型
- 値は型という集まりに分類される
- Int,Float,Integer,Double,リスト…
- 既存の型を組合せて新しい型も作れる
  - (Int, Int), Int -> Int なども
- 型固有の演算があり、他の型にその演算をしても意味がない
- 式であれば型を割り当てることができる
  - 式の型は式を構成する要素から推論
- 強い型付け
  - "式の型"は"式を構成する型"で決められる。
  - 決まらない場合は弱い型つけ
    - ? 暗黙的なキャストとかあると実行時の値によって型が変化する
  - 意味のある型を割り当てられない場合は不当な式となり、評価できない
  - 式 quad x = square square x の型
    - (square square) x
    - square square だけに注目
    - 前のsquare が受けとれるのは Integer, 渡される square は Integer -> Integer で一致しない
    - 不正
  - 利点
    - つづりミスや混乱した定義を発見できる
    - プログラムを書くときの規律になる
      - 値の定義を考える前に値の型を考えるようになる
      - 明瞭なプログラム設計ができる
** 1.6.1 多相型
- 関数には複数の型に対し適用できるものがある
- 例 関数合成はいろんな型に使用できる
- 型変数を導入することでできる
- ? それって型が決まるの？
- + 式に変数があっても問題ないのと同じ。
- 多相型
  - 型変数を含む型
- 型演算子 (->) は右結合
  - ! なんとなく型で使える演算子だとおもってたけど、型演算子だった!
** 1.6.2 型クラス
- (+) とか (*) 演算子は Int でも float でも使える
  - 型変数を導入して a -> a -> a とすると一般的すぎる
    - 蒸散できない型だって存在する
- 同類の型は型クラスとしてまとめられる
  - (+) ,(*) は 数値であれば使える
    - Float や Integer を数値という型クラスでまとめた。(Num クラス)
    - Num a => a -> a -> a
    - a がNumクラスのインスタンスであるという制約のもとで、 a -> a -> a
  - 3 のような数値リテラルの型は Integer でも Float でもよいので
    - 3 :: Num a => a
- 数値の他に
  - 値が表示可能な
  - 相等性検査可能な
  - 列挙可能な
- ある型は複数の型クラスのインスタンスになれる
- 型クラスの作りかたや、ある型クラスのインスタンスにする方法は別途
** 練習問題
[[file:1.6.lhs]]
* 1.7 定義
- 仕様
  - プログラムがなすべきことはどのようなことか
  - プログラマの意図
  - 利用者の期待
  - できる限り明確に
- 実装
  - 仕様を満たすプログラム
  - 実用的な実行時間とメモリ空間で実行できるもの
- 仕様と実装
  - 実装は仕様を満たす
  - そうなることを証明しなければいけない
- 仕様には計算方法は書かれない
- 関数の仕様を説明するのに 引数と戻り値を表明する方法もある
- 実行可能な仕様があるとしても、正しくて効率の良いプログラムをかく仕事はのこっている
- よりよい実装が存在する
- 最初に明確な仕様を与え、効率よくしていく
  - 30年前から研究されてる
  - ! BDDじゃないか？
- 難しい点がふたつ
  - 仕様が利用者の要求とずれてしまうかも。
  - 仕様を満たすための検証が膨大になりすぎて証明が大変
** 練習問題
[[file:1.7.hs]]
